"""
IntegrationManager for Vibecraft Framework v0.4.

This module provides the IntegrationManager class for integrating modules
into a unified project with interface and connector generation.
"""
from pathlib import Path
from typing import List, Optional

from vibecraft.modes.modular.module_registry import ModuleRegistry
from vibecraft.modes.modular.dependency_analyzer import DependencyAnalyzer
from vibecraft.core.exceptions import CyclicDependencyError, MissingDependencyError


class IntegrationManager:
    """
    Manages integration of modules into a unified project.
    
    Responsibilities:
    - Analyze module dependencies
    - Generate interfaces.py from module exports
    - Generate connectors for dependencies
    - Create integration directory structure
    """
    
    def __init__(self, project_root: Path):
        """
        Initialize IntegrationManager.
        
        Args:
            project_root: Root path of the Vibecraft project
        """
        self.project_root = project_root
        self.integration_dir = project_root / "integration"
        self.registry_path = project_root / ".vibecraft" / "modules-registry.json"
        self._registry: Optional[ModuleRegistry] = None
    
    @property
    def registry(self) -> ModuleRegistry:
        """Get or create ModuleRegistry."""
        if self._registry is None:
            self._registry = ModuleRegistry(self.registry_path)
        return self._registry
    
    def analyze_dependencies(self) -> List[str]:
        """
        Analyze module dependencies for errors.
        
        Returns:
            List of error messages (empty if no errors)
        """
        errors = []
        
        try:
            modules = self.registry.get_all()
            
            # Check for missing dependencies
            module_names = {m.name if hasattr(m, 'name') else m.get('name', '') for m in modules}
            for module in modules:
                mod_name = module.name if hasattr(module, 'name') else module.get('name', '')
                deps = module.dependencies if hasattr(module, 'dependencies') else module.get('dependencies', [])
                for dep in deps:
                    if dep not in module_names:
                        errors.append(f"Module '{mod_name}' depends on non-existent module '{dep}'")
            
            # Check for cycles
            analyzer = DependencyAnalyzer(self.registry)
            if analyzer.has_cycle():
                errors.append("Circular dependencies detected")
                
        except Exception as e:
            # Registry might not exist or be empty
            if "No such file" not in str(e):
                pass  # Empty registry is OK
        
        return errors
    
    def get_build_order(self) -> List[str]:
        """
        Get topological build order for modules.
        
        Returns:
            List of module names in build order
        """
        try:
            analyzer = DependencyAnalyzer(self.registry)
            return analyzer.get_build_order()
        except Exception:
            return []
    
    def build_project(self) -> None:
        """
        Build the integration layer for all modules.
        
        This method:
        1. Validates dependencies (raises on errors)
        2. Creates integration directory structure
        3. Generates interfaces.py
        4. Generates connectors
        """
        # First validate dependencies
        analyzer = DependencyAnalyzer(self.registry)
        
        try:
            analyzer.validate_dependencies()
        except MissingDependencyError as e:
            raise MissingDependencyError(str(e)) from e
        except CyclicDependencyError as e:
            raise CyclicDependencyError(str(e)) from e
        
        # Create integration directory
        self.integration_dir.mkdir(parents=True, exist_ok=True)
        
        # Generate interfaces
        self.generate_interfaces()
        
        # Generate connectors
        self.generate_connectors()
    
    def generate_interfaces(self) -> None:
        """
        Generate interfaces.py from module exports.
        
        Creates a file with Protocol classes for each exported symbol
        from all modules.
        """
        # Ensure integration dir exists
        self.integration_dir.mkdir(parents=True, exist_ok=True)
        
        interfaces_file = self.integration_dir / "interfaces.py"
        
        # Build interface definitions
        lines = [
            "# Auto-generated interfaces for all modules",
            "# DO NOT EDIT MANUALLY - Generated by IntegrationManager",
            "",
            "from typing import Protocol",
            "",
        ]
        
        try:
            modules = self.registry.get_all()
            
            for module in modules:
                module_name = module.name if hasattr(module, 'name') else module.get('name', 'unknown')
                exports = module.exports if hasattr(module, 'exports') else module.get('exports', [])
                
                for export in exports:
                    lines.append(f"class {export}(Protocol):")
                    lines.append(f'    """Interface from module: {module_name}"""')
                    lines.append("    pass")
                    lines.append("")
        except Exception:
            # Empty registry or error - create minimal file
            pass
        
        interfaces_file.write_text("\n".join(lines))
    
    def generate_connectors(self) -> None:
        """
        Generate connector files for module dependencies.
        
        Creates connector modules that facilitate communication
        between dependent modules.
        """
        # Ensure connectors dir exists
        connectors_dir = self.integration_dir / "connectors"
        connectors_dir.mkdir(parents=True, exist_ok=True)
        
        # Create __init__.py
        init_file = connectors_dir / "__init__.py"
        init_content = [
            "# Auto-generated connectors",
            "# DO NOT EDIT MANUALLY - Generated by IntegrationManager",
            "",
        ]
        
        try:
            modules = self.registry.get_all()
            
            for module in modules:
                module_name = module.name if hasattr(module, 'name') else module.get('name', 'unknown')
                dependencies = module.dependencies if hasattr(module, 'dependencies') else module.get('dependencies', [])
                exports = module.exports if hasattr(module, 'exports') else module.get('exports', [])
                
                if dependencies:
                    # Create connector file for this module's dependencies
                    connector_name = f"{module_name}_connector.py"
                    connector_file = connectors_dir / connector_name
                    
                    connector_lines = [
                        f"# Auto-generated connector for module: {module_name}",
                        "# DO NOT EDIT MANUALLY - Generated by IntegrationManager",
                        "",
                        "# Imports from dependency modules",
                    ]
                    
                    for dep in dependencies:
                        connector_lines.append(f"from ...modules.{dep} import *")
                    
                    connector_lines.append("")
                    connector_lines.append(f"# Connector for {module_name}")
                    connector_lines.append(f"# Depends on: {', '.join(dependencies)}")
                    connector_lines.append("")
                    
                    # Add exports/funcs for this connector
                    if exports:
                        connector_lines.append("# Exported interfaces")
                        for exp in exports:
                            connector_lines.append(f"def {exp}():")
                            connector_lines.append(f'    """Proxy for {exp} from {module_name}"""')
                            connector_lines.append("    pass")
                            connector_lines.append("")
                    
                    connector_file.write_text("\n".join(connector_lines))

                    # Add to __init__.py
                    init_content.append(f"from .{connector_name[:-3]} import *")
                    
        except Exception:
            # Empty registry or error - create minimal __init__.py
            pass
        
        init_file.write_text("\n".join(init_content))
